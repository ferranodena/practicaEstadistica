predicted_df$predicted_price <- exp(predict(model, newdata = predicted_df))
# Create a simple plot
plot(predicted_df$amenities_premium_count, predicted_df$predicted_price,
type = "b", col = "blue", pch = 16,
xlab = "Number of Rare Amenities",
ylab = "Predicted Price",
main = "Effect of Rare Amenities on Price\n(Controlling for Size and Location)")
# Step 1: Simple model to answer the main question
model <- lm(log(price) ~ square_feet + neighbourhood + amenities_premium_count, data = df)
# Print the summary to see if amenities_premium_count has a significant effect
summary(model)
# Step 2: Extract the coefficient for amenities_premium_count
premium_coef <- coef(model)["amenities_premium_count"]
# Step 3: Calculate the percentage effect (since we used log price)
percentage_effect <- (exp(premium_coef) - 1) * 100
# Step 4: Print the result in a clear way
cat("When controlling for size and location:\n")
cat(paste("Each additional rare amenity changes price by approximately",
round(percentage_effect, 2), "%\n"))
# Step 5: Simple visualization - using actual data instead of predictions
# Create boxplot to compare prices by number of rare amenities
boxplot(price ~ amenities_premium_count, data = df,
col = "skyblue",
xlab = "Number of Rare Amenities",
ylab = "Price",
main = "Price Distribution by Number of Rare Amenities")
# Alternative: create a barplot of average prices
rare_counts <- sort(unique(df$amenities_premium_count))
avg_prices <- sapply(rare_counts, function(x) mean(df$price[df$amenities_premium_count == x], na.rm=TRUE))
barplot(avg_prices,
names.arg = rare_counts,
col = "steelblue",
xlab = "Number of Rare Amenities",
ylab = "Average Price",
main = "Average Price by Number of Rare Amenities")
data <- read.csv("./base_dades_districtes.csv")
# Step 1: Classify hosts based on listings count (lowest 25% vs middle 50% vs highest 25%)
lower_q <- quantile(data$host_listings_count, 0.25, na.rm = TRUE)
upper_q <- quantile(data$host_listings_count, 0.75, na.rm = TRUE)
# Create the classification
data$host_category <- ifelse(data$host_listings_count <= lower_q, "Low",
ifelse(data$host_listings_count >= upper_q, "High", "Medium"))
# Step 2: Calculate price dispersion metrics by category
# Function to calculate statistics by group
calculate_stats <- function(group) {
prices <- data$price[data$host_category == group]
mean_val <- mean(prices, na.rm = TRUE)
median_val <- median(prices, na.rm = TRUE)
std_dev <- sd(prices, na.rm = TRUE)
coef_var <- (std_dev / mean_val) * 100
iqr_val <- IQR(prices, na.rm = TRUE)
min_val <- min(prices, na.rm = TRUE)
max_val <- max(prices, na.rm = TRUE)
range_val <- max_val - min_val
count_val <- length(prices)
return(c(mean_val, median_val, std_dev, coef_var, iqr_val, min_val, max_val, range_val, count_val))
}
# Calculate statistics for each group
stats_low <- calculate_stats("Low")
stats_medium <- calculate_stats("Medium")
stats_high <- calculate_stats("High")
# Create results data frame
price_dispersion <- data.frame(
host_category = c("Low", "Medium", "High"),
mean_price = c(stats_low[1], stats_medium[1], stats_high[1]),
median_price = c(stats_low[2], stats_medium[2], stats_high[2]),
sd_price = c(stats_low[3], stats_medium[3], stats_high[3]),
cv_price = c(stats_low[4], stats_medium[4], stats_high[4]),
iqr_price = c(stats_low[5], stats_medium[5], stats_high[5]),
min_price = c(stats_low[6], stats_medium[6], stats_high[6]),
max_price = c(stats_low[7], stats_medium[7], stats_high[7]),
price_range = c(stats_low[8], stats_medium[8], stats_high[8]),
count = c(stats_low[9], stats_medium[9], stats_high[9])
)
# Display the summary
print(price_dispersion)
# Step 3: Create visualizations using basic R functions
# 1) Boxplot to compare price distribution
boxplot(price ~ host_category, data = data,
main = "Price Distribution by Host Category",
xlab = "Host Category", ylab = "Price",
col = c("skyblue", "lightgreen", "coral"),
ylim = c(0, quantile(data$price, 0.95, na.rm = TRUE)),
las = 1)
# 3) Bar chart of coefficient of variation
barplot(price_dispersion$cv_price,
names.arg = price_dispersion$host_category,
main = "Coefficient of Variation by Category",
xlab = "Host Category", ylab = "CV (%)",
col = c("skyblue", "lightgreen", "coral"))
room_type_by_category <- table(data$host_category, data$room_type)
room_type_prop <- prop.table(room_type_by_category, 1) * 100  # Percentage by row
print("Distribution of the listings categories by host type(%):")
print(round(room_type_prop, 2))
# Create stacked barplot from the room type proportions
barplot(t(room_type_prop),
main = "Accommodation Types by Host Category (%)",
xlab = "Host Category",
ylab = "Percentage (%)",
col = c("steelblue", "coral", "lightgreen"),
legend.text = colnames(room_type_prop),
args.legend = list(x = "topright", cex = 0.8))
dataset <- read.csv("./base_dades_districtes.csv")
# Step 1: Classify response times as fast or slow
# Fast response is defined as "within an hour" OR "within a few hours"
dataset$response_speed <- ifelse(dataset$host_response_time %in% c("within an hour","within a few hours"),
"Fast",
ifelse(dataset$host_response_time == "N/A",
NA, "Slow"))
# Step 2: Define last-minute friendly listings (low minimum nights & low availability), medians are the threshold
min_nights_threshold <- median(dataset$minimum_nights, na.rm = TRUE)
availability_threshold <- median(dataset$availability_365, na.rm = TRUE)
dataset$last_minute_friendly <- ifelse(dataset$minimum_nights <= min_nights_threshold &
dataset$availability_365 <= availability_threshold,
"Last-minute friendly", "Regular")
# Step 3: Create contingency table to see relationship between response time and last-minute friendliness
# Remove NA values for clean analysis
response_data <- dataset[!is.na(dataset$response_speed), ]
response_lastminute_table <- table(response_data$response_speed, response_data$last_minute_friendly)
response_lastminute_prop <- prop.table(response_lastminute_table, 1) * 100  # Row percentages
# Display results
print("Percentage of last-minute friendly listings by response time:")
print(round(response_lastminute_prop, 2))
# Step 4: Calculate occupancy and rating statistics by group
# Using number_of_reviews as a proxy for occupancy (more reviews = higher occupancy)
occupancy_by_response <- tapply(response_data$number_of_reviews, response_data$response_speed,
function(x) c(mean = mean(x, na.rm = TRUE),
median = median(x, na.rm = TRUE)))
ratings_by_response <- tapply(response_data$review_scores_rating, response_data$response_speed,
function(x) c(mean = mean(x, na.rm = TRUE),
median = median(x, na.rm = TRUE)))
print("Occupancy statistics (number of reviews) by response time:")
print(occupancy_by_response)
print("Rating statistics by response time:")
print(ratings_by_response)
# Step 5: Visualization with simple plots
# Bar chart showing proportion of last-minute friendly listings
barplot(response_lastminute_prop[, "Last-minute friendly"],
main = "% of Last-minute Friendly Listings by Response Time",
xlab = "Host Response Time",
ylab = "Percentage (%)",
col = c("coral", "steelblue"),
names.arg = c("Fast", "Slow"))
# Box plots comparing reviews and ratings
par(mfrow = c(1, 2))
boxplot(number_of_reviews ~ response_speed, data = response_data,
main = "Number of Reviews by Response Time",
xlab = "Host Response Time",
ylab = "Number of Reviews",
col = c("coral", "steelblue"))
boxplot(review_scores_rating ~ response_speed, data = response_data,
main = "Ratings by Response Time",
xlab = "Host Response Time",
ylab = "Rating Score",
col = c("coral", "steelblue"))
par(mfrow = c(1, 1))
# First plot without number_of_reviews
library(ggplot2)
data <- read.csv("base_dades_districtes.csv")
ggplot(data, aes(x = price, y = review_scores_rating)) +
geom_point(alpha = 0.5) +
geom_smooth(method = "lm", color = "red") +
labs(title = "Relationship between Price and Rating",
x = "Price",
y = "Rating") +
theme_minimal()
# Correlation matrix with just price and rating
cor_matrix <- cor(data[c("price", "review_scores_rating")])
print(round(cor_matrix, 3))
library(ggplot2)
data <- read.csv("base_dades_districtes.csv")
# Gràfic: Preu vs Nombre de reviews, color segons puntuació
ggplot(data, aes(x = price, y = number_of_reviews, color = review_scores_rating)) +
geom_point(alpha = 0.7, size = 2) +
scale_color_gradient(low = "yellow", high = "blue") +
labs(title = "Price vs Number of reviews (color: rating)",
x = "Price",
y = "Number of reviews",
color = "Rating") +
theme_minimal()
library(ggplot2)
data <- read.csv("base_dades_districtes.csv")
# Gràfic: Nombre de reviews vs Puntuació mitjana
ggplot(data, aes(x = number_of_reviews, y = review_scores_rating)) +
geom_point(alpha = 0.6, color = "darkgreen", size = 2) +
geom_smooth(method = "lm", color = "red") +
labs(title = "Number of reviews vs Average rating",
x = "Number of reviews",
y = "Average rating") +
theme_minimal()
real_estate <- read.csv("base_dades_districtes.csv")
# Scatter plot to study the correlation between square_feet and price (excluding 0 values)
library(ggplot2)
# Remove rows with missing or zero values in square_feet or price
filtered_data <- real_estate[!is.na(real_estate$square_feet) &
!is.na(real_estate$price) &
real_estate$square_feet > 0, ]
ggplot(filtered_data, aes(x = square_feet, y = price)) +
geom_point(alpha = 0.6, color = "blue") +
geom_smooth(method = "lm", se = TRUE, color = "red", linewidth = 1.2) +
labs(
title = "Correlation between Square Feet and Price",
x = "Square Feet",
y = "Price ($)"
) +
theme_minimal()
# Barplot to compare average price by neighbourhood
library(ggplot2)
# Remove rows with missing values in price or neighbourhood
filtered_data <- real_estate[!is.na(real_estate$price) & !is.na(real_estate$neighbourhood), ]
# Calculate median price for labels
median_prices <- aggregate(price ~ neighbourhood, filtered_data, median)
ggplot(filtered_data, aes(x = reorder(neighbourhood, price, FUN = median), y = price/1000)) +
geom_boxplot(fill = "skyblue", alpha = 0.7) +
labs(
title = "House Price Distribution by Neighbourhood",
subtitle = "Boxplots showing price spread in each area",
x = "Neighbourhood",
y = "Price (Thousands $)"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
plot.title = element_text(size = 14, face = "bold"),
plot.subtitle = element_text(size = 12),
axis.title = element_text(size = 12)
)
# Scatter plot: Price vs Amenities Count
real_estate <- read.csv("base_dades_districtes.csv")
filtered_data1 <- real_estate[!is.na(real_estate$price) & !is.na(real_estate$amenities_count), ]
ggplot(filtered_data1, aes(x = amenities_count, y = price)) +
geom_point(alpha = 0.6, color = "blue") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
labs(
title = "Price vs Amenities Count",
x = "Amenities Count",
y = "Price ($)"
) +
theme_minimal()
# Scatter plot: Price vs Premium Amenities Count
filtered_data2 <- real_estate[!is.na(real_estate$price) & !is.na(real_estate$amenities_premium_count), ]
ggplot(filtered_data2, aes(x = amenities_premium_count, y = price)) +
geom_point(alpha = 0.6, color = "darkgreen") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
labs(
title = "Price vs Premium Amenities Count",
x = "Premium Amenities Count",
y = "Price ($)"
) +
theme_minimal()
# Correlation calculation
cor1 <- cor(filtered_data1$price, filtered_data1$amenities_count)
cor2 <- cor(filtered_data2$price, filtered_data2$amenities_premium_count)
print(paste("Correlation between price and amenities count:", round(cor1, 2)))
print(paste("Correlation between price and premium amenities count:", round(cor2, 2)))
# Barplot to compare average price by neighbourhood using log scale
library(ggplot2)
# Remove rows with missing values in price or neighbourhood
filtered_data <- real_estate[!is.na(real_estate$price) & !is.na(real_estate$neighbourhood), ]
# Calculate median price for labels
median_prices <- aggregate(price ~ neighbourhood, filtered_data, median)
ggplot(filtered_data, aes(x = reorder(neighbourhood, price, FUN = median), y = price)) +
geom_boxplot(fill = "skyblue", alpha = 0.7) +
scale_y_log10(labels = scales::label_number(scale = 1e-3, suffix = "K")) +
labs(
title = "House Price Distribution by Neighbourhood",
subtitle = "Boxplots showing price spread in each area (log scale)",
x = "Neighbourhood",
y = "Price (Thousands $, log scale)"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 45, hjust = 1, size = 10),
plot.title = element_text(size = 14, face = "bold"),
plot.subtitle = element_text(size = 12),
axis.title = element_text(size = 12)
)
# Scatter plot: Price vs Amenities Count
real_estate <- read.csv("base_dades_districtes.csv")
filtered_data1 <- real_estate[!is.na(real_estate$price) & !is.na(real_estate$amenities_count), ]
ggplot(filtered_data1, aes(x = amenities_count, y = price)) +
geom_point(alpha = 0.6, color = "blue") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
labs(
title = "Price vs Amenities Count",
x = "Amenities Count",
y = "Price ($)"
) +
theme_minimal()
# Scatter plot: Price vs Premium Amenities Count
filtered_data2 <- real_estate[!is.na(real_estate$price) & !is.na(real_estate$amenities_premium_count), ]
ggplot(filtered_data2, aes(x = amenities_premium_count, y = price)) +
geom_point(alpha = 0.6, color = "darkgreen") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
labs(
title = "Price vs Premium Amenities Count",
x = "Premium Amenities Count",
y = "Price ($)"
) +
theme_minimal()
# Correlation calculation
cor1 <- cor(filtered_data1$price, filtered_data1$amenities_count)
cor2 <- cor(filtered_data2$price, filtered_data2$amenities_premium_count)
print(paste("Correlation between price and amenities count:", round(cor1, 2)))
print(paste("Correlation between price and premium amenities count:", round(cor2, 2)))
library(ggplot2)
real_estate <- read.csv("base_dades_districtes.csv")
# Scatter plot: Price vs Amenities Count (log-log)
filtered_data1 <- real_estate[!is.na(real_estate$price) &
!is.na(real_estate$amenities_count) &
real_estate$price > 0 &
real_estate$amenities_count > 0, ]
ggplot(filtered_data1, aes(x = amenities_count, y = price)) +
geom_point(alpha = 0.6, color = "blue") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
scale_x_log10() +
scale_y_log10(labels = scales::label_dollar()) +
labs(
title = "Price vs Amenities Count (Log-Log Scale)",
x = "Amenities Count (log scale)",
y = "Price ($, log scale)"
) +
theme_minimal()
# Scatter plot: Price vs Premium Amenities Count (log-log)
filtered_data2 <- real_estate[!is.na(real_estate$price) &
!is.na(real_estate$amenities_premium_count) &
real_estate$price > 0 &
real_estate$amenities_premium_count > 0, ]
ggplot(filtered_data2, aes(x = amenities_premium_count, y = price)) +
geom_point(alpha = 0.6, color = "darkgreen") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
scale_x_log10() +
scale_y_log10(labels = scales::label_dollar()) +
labs(
title = "Price vs Premium Amenities Count (Log-Log Scale)",
x = "Premium Amenities Count (log scale)",
y = "Price ($, log scale)"
) +
theme_minimal()
# Correlation calculation (still in linear space)
cor1 <- cor(filtered_data1$price, filtered_data1$amenities_count)
cor2 <- cor(filtered_data2$price, filtered_data2$amenities_premium_count)
print(paste("Correlation between price and amenities count:", round(cor1, 2)))
print(paste("Correlation between price and premium amenities count:", round(cor2, 2)))
library(ggplot2)
real_estate <- read.csv("base_dades_districtes.csv")
# Scatter plot: Price vs Amenities Count (log y-axis)
filtered_data1 <- real_estate[!is.na(real_estate$price) &
!is.na(real_estate$amenities_count) &
real_estate$price > 0, ]
ggplot(filtered_data1, aes(x = amenities_count, y = price)) +
geom_point(alpha = 0.6, color = "blue") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
scale_y_log10(labels = scales::label_dollar()) +
labs(
title = "Price vs Amenities Count (Log Y-axis)",
x = "Amenities Count",
y = "Price ($, log scale)"
) +
theme_minimal()
# Scatter plot: Price vs Premium Amenities Count (log y-axis)
filtered_data2 <- real_estate[!is.na(real_estate$price) &
!is.na(real_estate$amenities_premium_count) &
real_estate$price > 0, ]
ggplot(filtered_data2, aes(x = amenities_premium_count, y = price)) +
geom_point(alpha = 0.6, color = "darkgreen") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
scale_y_log10(labels = scales::label_dollar()) +
labs(
title = "Price vs Premium Amenities Count (Log Y-axis)",
x = "Premium Amenities Count",
y = "Price ($, log scale)"
) +
theme_minimal()
# Correlation calculation (still in linear space)
cor1 <- cor(filtered_data1$price, filtered_data1$amenities_count)
cor2 <- cor(filtered_data2$price, filtered_data2$amenities_premium_count)
print(paste("Correlation between price and amenities count:", round(cor1, 2)))
print(paste("Correlation between price and premium amenities count:", round(cor2, 2)))
# Scatter plot: Price vs Square Feet
real_estate <- read.csv("base_dades_districtes.csv")
filtered_data_sqft <- real_estate[!is.na(real_estate$price) & !is.na(real_estate$square_feet) & real_estate$square_feet > 0, ]
ggplot(filtered_data_sqft, aes(x = square_feet, y = price)) +
geom_point(alpha = 0.6, color = "purple") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
labs(
title = "Price vs Square Feet",
x = "Square Feet",
y = "Price ($)"
) +
theme_minimal()
# Correlation calculation
cor_sqft <- cor(filtered_data_sqft$price, filtered_data_sqft$square_feet)
print(paste("Correlation between price and square feet:", round(cor_sqft, 2)))
# Scatter plot: Price vs Square Feet
real_estate <- read.csv("base_dades_districtes.csv")
filtered_data_sqft <- real_estate[!is.na(real_estate$price) & !is.na(real_estate$square_feet) & real_estate$square_feet > 0, ]
ggplot(filtered_data_sqft, aes(x = square_feet, y = price)) +
geom_point(alpha = 0.6, color = "purple") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
labs(
title = "Price vs Square Feet",
x = "Square Feet",
y = "Price ($)"
) +
theme_minimal()
real_estate <- read.csv("base_dades_districtes.csv")
# Scatter plot to study the correlation between square_feet and price (excluding 0 values)
library(ggplot2)
# Remove rows with missing or zero values in square_feet or price
filtered_data <- real_estate[!is.na(real_estate$square_feet) &
!is.na(real_estate$price) &
real_estate$square_feet > 0, ]
ggplot(filtered_data, aes(x = square_feet, y = price)) +
geom_point(alpha = 0.6, color = "blue") +
geom_smooth(method = "lm", se = TRUE, color = "red", linewidth = 1.2) +
labs(
title = "Correlation between Square Feet and Price",
x = "Square Feet",
y = "Price ($)"
) +
theme_minimal()
# Scatter plot: Price vs Accommodates
real_estate <- read.csv("base_dades_districtes.csv")
filtered_data_acc <- real_estate[!is.na(real_estate$price) & !is.na(real_estate$accommodates), ]
# Calculate Q1 and Q3 for price
Q1 <- quantile(filtered_data_acc$price, 0.25)
Q3 <- quantile(filtered_data_acc$price, 0.75)
IQR <- Q3 - Q1
# Filter out extreme outliers (more than 1.5 * IQR)
filtered_data_acc <- filtered_data_acc[filtered_data_acc$price <= (Q3 + 1.5 * IQR), ]
ggplot(filtered_data_acc, aes(x = accommodates, y = price)) +
geom_point(alpha = 0.6, color = "orange") +
geom_smooth(method = "lm", se = TRUE, color = "red") +
labs(
title = "Price vs Accommodates (Excluding Extreme Outliers)",
x = "Accommodates (Number of Guests)",
y = "Price ($)"
) +
theme_minimal() +
scale_y_continuous(limits = c(0, Q3 + 1.5 * IQR))
# Correlation calculation
cor_acc <- cor(filtered_data_acc$price, filtered_data_acc$accommodates)
print(paste("Correlation between price and accommodates:", round(cor_acc, 2)))
data <- read.csv(".\\base_dades_districtes.csv")
# Carregar les llibreries necessàries
if (!requireNamespace("corrplot", quietly = TRUE)) {
install.packages("corrplot")
}
library(corrplot)
# Filtrem només les columnes numèriques (excloent les que hem creat pel càlcul del professionalism)
cols_to_exclude <- c("availability_score", "listings_score", "response_time_score")
cols_to_exclude <- cols_to_exclude[cols_to_exclude %in% names(data_numeric)]  # Ensure columns exist
# 1. Veiem les classes de cada columna
str(data)
# 2. Filtrem només les columnes numèriques
data_numeric <- data[, sapply(data, is.numeric)]
# 3. Calculem la matriu de correlació només amb les columnes numèriques
cor_matrix <- cor(data_numeric, use = "complete.obs")
# 4. Mostrem la matriu de correlació
print(cor_matrix)
# Carregar les llibreries necessàries
if (!requireNamespace("corrplot", quietly = TRUE)) {
install.packages("corrplot")
}
library(corrplot)
# Filtrem només les columnes numèriques (excloent les que hem creat pel càlcul del professionalism)
cols_to_exclude <- c("availability_score", "listings_score", "response_time_score")
cols_to_exclude <- cols_to_exclude[cols_to_exclude %in% names(data_numeric)]  # Ensure columns exist
data_numeric_filtered <- data_numeric[, !names(data_numeric) %in% cols_to_exclude]
# Calculem la matriu de correlació
cor_matrix <- cor(data_numeric_filtered, use = "pairwise.complete.obs")
# Visualitzem el mapa de correlacions amb rectangles colorejats en lloc de cercles
corrplot(cor_matrix,
method = "color",   # Utilitzem colors sòlids en lloc de cercles
type = "upper",     # Mostrar només la part superior de la matriu
order = "hclust",   # Ordenar variables per similitud de correlacions
tl.col = "black",   # Color del text de les etiquetes
tl.srt = 45,        # Rotació del text (45 graus)
addCoef.col = "black", # Color dels coeficients
number.cex = 0.7,   # Mida dels coeficients
tl.cex = 0.7,       # Mida de les etiquetes
col = colorRampPalette(c("#6D9EC1", "white", "#E46726"))(200),
title = "Mapa de correlacions entre les variables numèriques",
mar = c(0, 0, 1, 0)) # Marges del gràfic
# Crear una visualització més detallada amb números
par(mfrow = c(1, 1))  # Restablir la configuració del gràfic
# Carregar les llibreries necessàries
if (!requireNamespace("corrplot", quietly = TRUE)) {
install.packages("corrplot")
}
library(corrplot)
# Filtrem només les columnes numèriques (excloent les que hem creat pel càlcul del professionalism)
cols_to_exclude <- c("availability_score", "listings_score", "response_time_score")
cols_to_exclude <- cols_to_exclude[cols_to_exclude %in% names(data_numeric)]  # Ensure columns exist
data_numeric_filtered <- data_numeric[, !names(data_numeric) %in% cols_to_exclude]
# Calculem la matriu de correlació
cor_matrix <- cor(data_numeric_filtered, use = "pairwise.complete.obs")
# Visualitzem el mapa de correlacions amb rectangles colorejats en lloc de cercles
corrplot(cor_matrix,
method = "color",   # Utilitzem colors sòlids en lloc de cercles
type = "upper",     # Mostrar només la part superior de la matriu
order = "hclust",   # Ordenar variables per similitud de correlacions
tl.col = "black",   # Color del text de les etiquetes
tl.srt = 45,        # Rotació del text (45 graus)
addCoef.col = "black", # Color dels coeficients
number.cex = 0.7,   # Mida dels coeficients
tl.cex = 0.7,       # Mida de les etiquetes
col = colorRampPalette(c("#6D9EC1", "white", "#E46726"))(200),
mar = c(0, 0, 1, 0)) # Marges del gràfic
# Crear una visualització més detallada amb números
par(mfrow = c(1, 1))  # Restablir la configuració del gràfic
